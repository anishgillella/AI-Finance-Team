import { ChatOpenAI } from "@langchain/openai";
import { SystemMessage, HumanMessage } from "@langchain/core/messages";
import dotenv from "dotenv";
import { getCoreSchemaDescription, getSchemaDescription } from "./schema-registry.js";

dotenv.config();

export interface TokenUsage {
  totalTokens: number;
  totalCost: number;
}

let totalTokenUsage: TokenUsage = {
  totalTokens: 0,
  totalCost: 0,
};

const llm = new ChatOpenAI({
  apiKey: process.env.OPENROUTER_API_KEY,
  model: process.env.OPENROUTER_MODEL || "openai/gpt-4o-mini",
  baseURL: "https://openrouter.ai/api/v1",
  temperature: 0.2, // Lower temperature for more consistency
  maxTokens: 500,
});

export interface GeneratedSQL {
  sql: string;
  reasoning: string;
  tokensUsed: number;
}

export async function generateSQL(
  userQuery: string,
  semanticContext?: string
): Promise<GeneratedSQL> {
  // Build context
  let contextForPrompt = semanticContext || "";

  const contextType = semanticContext ? "semantic" : "core";
  if (!semanticContext) {
    console.log("   📝 Using core schema (optimized, 60% token savings vs full schema)");
    contextForPrompt = await getCoreSchemaDescription();
  } else {
    console.log("   📝 Using optimized semantic context (75% token savings)");
  }

  // Few-shot examples specific to the schema
  const fewShotExamples = `
## FINANCIAL QUERY EXAMPLES - FOLLOW THESE PATTERNS EXACTLY:

Example 1: "How many accounts do we have?"
SQL: SELECT COUNT(*) AS total_accounts FROM accounts;

Example 2: "Show top 5 securities by market cap"
SQL: SELECT ticker, name, security_type, market_cap FROM securities ORDER BY market_cap DESC LIMIT 5;

Example 3: "What are my portfolio holdings with security details?"
SQL: SELECT ph.id, s.name, s.ticker, ph.quantity, ph.current_price, ph.market_value FROM portfolio_holdings ph LEFT JOIN securities s ON ph.security_id = s.id ORDER BY ph.market_value DESC LIMIT 100;

Example 4: "Show spending by category"
SQL: SELECT category, COUNT(*) as transaction_count, SUM(amount) as total_spent FROM transactions WHERE category IS NOT NULL GROUP BY category ORDER BY total_spent DESC;

Example 5: "Get transaction history with account details"
SQL: SELECT t.transaction_date, t.transaction_type, t.amount, t.category, a.account_name FROM transactions t LEFT JOIN accounts a ON t.account_id = a.id ORDER BY t.transaction_date DESC LIMIT 100;

Example 6: "Show budget status"
SQL: SELECT category, limit_amount, spent_amount, ROUND((spent_amount::decimal / limit_amount * 100), 2) as percent_used FROM budgets ORDER BY percent_used DESC;

Example 7: "Get dividend history with security details"
SQL: SELECT s.name, s.ticker, d.payment_date, d.amount_per_share, d.total_amount FROM dividends d LEFT JOIN securities s ON d.security_id = s.id ORDER BY d.payment_date DESC LIMIT 50;

Example 8: "Show portfolio performance with gains"
SQL: SELECT s.name, s.ticker, ph.quantity, ph.average_cost, ph.current_price, (ph.current_price - ph.average_cost) as gain_per_share FROM portfolio_holdings ph LEFT JOIN securities s ON ph.security_id = s.id ORDER BY (ph.current_price - ph.average_cost) DESC;

Example 9: "Get user accounts with balances"
SQL: SELECT u.email, u.name, a.account_name, a.account_type, a.balance FROM users u LEFT JOIN accounts a ON u.id = a.user_id ORDER BY u.email LIMIT 100;

Example 10: "Show accounts grouped by type"
SQL: SELECT account_type, COUNT(*) as count, SUM(balance) as total_balance FROM accounts GROUP BY account_type ORDER BY count DESC;`;

  // CRITICAL: Always use these exact table names - NO variations!
  const tableConstraints = `
## MANDATORY TABLE NAMES (Use EXACTLY as shown):
- users (columns: id, email, name, phone, country, role, created_at, updated_at)
- accounts (columns: id, user_id, account_type, account_name, balance, currency, account_number, institution_name, created_at, updated_at)
- transactions (columns: id, account_id, security_id, transaction_type, amount, quantity, price_per_unit, transaction_date, description, category, merchant, status, created_at)
- securities (columns: id, ticker, name, security_type, sector, industry, market_cap, description, created_at)
- portfolio_holdings (columns: id, account_id, security_id, quantity, average_cost, current_price, market_value, acquisition_date, created_at, updated_at)
- price_history (columns: id, security_id, history_date, open_price, close_price, high_price, low_price, volume, created_at)
- dividends (columns: id, security_id, account_id, ex_date, record_date, payment_date, amount_per_share, total_amount, created_at)
- budgets (columns: id, user_id, category, limit_amount, spent_amount, budget_month, budget_year, created_at, updated_at)
- expense_categories (columns: id, user_id, category_name, color, icon, description, created_at)
- financial_goals (columns: id, user_id, goal_name, goal_type, target_amount, current_amount, target_date, priority, status, created_at, updated_at)
- schema_registry (columns: id, table_name, description, col_defs, rel_defs, sens_fields, is_queryable, created_at, updated_at)

REMEMBER: 
- NOT "portfolios" - use "portfolio_holdings"
- NOT "holdings" - use "portfolio_holdings"
- NOT "budget" - use "budgets"
- NOT "spending" - use "transactions"
- Always use table aliases (ph, s, a, u, t, d, etc.)
`;

  // System prompt with schema context and few-shot examples
  const systemPrompt = `You are an expert SQL developer for a financial database. Your job is to generate ONLY valid SELECT queries.

CRITICAL RULES:
1. ONLY generate SELECT queries - NO INSERT, DELETE, UPDATE, DROP, ALTER, etc.
2. Use EXACT table and column names from the list below
3. Always add LIMIT to prevent large result sets (max 100)
4. Use LEFT JOIN for multi-table queries (prefer LEFT JOIN over INNER JOIN)
5. Use table aliases for all columns (e.g., ph.id, s.name, a.account_name)
6. For GROUP BY queries, include all non-aggregated columns
7. Always validate table names - refer to the mandatory table list below
8. Follow the examples provided - they show the CORRECT patterns
9. Never assume column names - use EXACTLY what's in the table list

${tableConstraints}

${contextForPrompt}

${fewShotExamples}

RESPONSE FORMAT:
You MUST respond with exactly this format:
REASONING: [one line explanation]
SQL: [complete SELECT query]

Example response:
REASONING: Count all accounts in the system
SQL: SELECT COUNT(*) AS total_accounts FROM accounts;`;

  const userMessage = `Generate a SQL query for this request: "${userQuery}"

Remember to:
1. Check the mandatory table names above
2. Use exact column names
3. Follow one of the examples if your query is similar
4. Always include LIMIT`;

  try {
    console.log("🔍 Generating SQL with improved constraints...");
    
    const response = await llm.invoke([
      new SystemMessage(systemPrompt),
      new HumanMessage(userMessage),
    ]);

    const responseText = response.content.toString();
    
    // Parse response
    const reasoningMatch = responseText.match(/REASONING:\s*(.+?)(?=SQL:|$)/is);
    const sqlMatch = responseText.match(/SQL:\s*(.+?)$/is);

    if (!sqlMatch) {
      throw new Error(`Failed to parse SQL from response: ${responseText.substring(0, 200)}`);
    }

    let sql = sqlMatch[1].trim();
    // Remove trailing semicolon if present (parser will add it)
    if (sql.endsWith(";")) {
      sql = sql.slice(0, -1).trim();
    }

    const reasoning = reasoningMatch ? reasoningMatch[1].trim() : "SQL query generated";

    // Token counting (approximate)
    const inputTokens = Math.ceil(userQuery.length / 4 + systemPrompt.length / 4);
    const outputTokens = Math.ceil(responseText.length / 4);
    const totalTokens = inputTokens + outputTokens;

    totalTokenUsage.totalTokens += totalTokens;
    // Approximate cost for GPT-4o-mini
    totalTokenUsage.totalCost += (inputTokens * 0.00015 + outputTokens * 0.0006) / 1000;

    console.log(`   ✓ SQL generated: ${sql.substring(0, 80)}...`);
    
    return { sql, reasoning, tokensUsed: totalTokens };
  } catch (error) {
    throw new Error(
      `Failed to generate SQL: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

export function getTokenUsage(): TokenUsage {
  return { ...totalTokenUsage };
}

export function resetTokenUsage(): void {
  totalTokenUsage = {
    totalTokens: 0,
    totalCost: 0,
  };
}

export function formatTokenUsageSummary(): string {
  const usage = getTokenUsage();
  return `
  ═══════════════════════════════════════
  💾 TOKEN USAGE SUMMARY
  ═══════════════════════════════════════
  Total Tokens: ${usage.totalTokens.toLocaleString()}
  Estimated Cost: $${usage.totalCost.toFixed(6)}
  ═══════════════════════════════════════
  `;
}

export default generateSQL;
